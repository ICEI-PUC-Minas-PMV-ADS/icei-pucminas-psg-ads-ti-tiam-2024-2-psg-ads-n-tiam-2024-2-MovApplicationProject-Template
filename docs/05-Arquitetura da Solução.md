# Arquitetura da Solução
## Diagrama de Classes

![Untitled (1)](https://github.com/user-attachments/assets/1655012a-bc3a-46ad-b77b-6022671425bf)



## Modelo ER
![Untitled](https://github.com/user-attachments/assets/825adafb-0b31-4429-ae92-3b3807a38997)




## Esquema Relacional

O Esquema Relacional corresponde à representação dos dados em tabelas juntamente com as restrições de integridade e chave primária.
 
As referências abaixo irão auxiliá-lo na geração do artefato “Esquema Relacional”.

> - [Criando um modelo relacional - Documentação da IBM](https://www.ibm.com/docs/pt-br/cognos-analytics/10.2.2?topic=designer-creating-relational-model)

## Modelo Físico

Entregar um arquivo banco.sql contendo os scripts de criação das tabelas do banco de dados. Este arquivo deverá ser incluído dentro da pasta src\bd.

## Tecnologias Utilizadas

Descreva aqui qual(is) tecnologias você vai usar para resolver o seu problema, ou seja, implementar a sua solução. Liste todas as tecnologias envolvidas, linguagens a serem utilizadas, serviços web, frameworks, bibliotecas, IDEs de desenvolvimento, e ferramentas.

Apresente também uma figura explicando como as tecnologias estão relacionadas ou como uma interação do usuário com o sistema vai ser conduzida, por onde ela passa até retornar uma resposta ao usuário.

## Hospedagem

Explique como a hospedagem e o lançamento da plataforma foi feita.

> **Links Úteis**:
>
> - [Website com GitHub Pages](https://pages.github.com/)
> - [Programação colaborativa com Repl.it](https://repl.it/)
> - [Getting Started with Heroku](https://devcenter.heroku.com/start)
> - [Publicando Seu Site No Heroku](http://pythonclub.com.br/publicando-seu-hello-world-no-heroku.html)

## Qualidade de Software

## Características e Subcaracterísticas de Qualidade para o Projeto de Software

### 1. Funcionalidade
- **Adequação Funcional**: O sistema deve atender às necessidades de registro de notas e presença.
- **Precisão**: Os dados inseridos devem refletir a realidade do desempenho e presença.
- **Interoperabilidade**: O sistema deve ser compatível com outros sistemas da escola.

### 2. Confiabilidade
- **Maturidade**: O sistema deve ter baixa ocorrência de falhas.
- **Disponibilidade**: Garantir disponibilidade mínima de 95%.
- **Tolerância a Falhas**: Operação correta mesmo em caso de erro, evitando perda de dados.

### 3. Usabilidade
- **Inteligibilidade**: O sistema deve ser fácil de entender e usar.
- **Apreensibilidade**: Os usuários devem aprender rapidamente a utilizar o sistema.
- **Operabilidade**: A interface deve ser simples e permitir uso eficiente com mínimo esforço.

### 4. Eficiência de Desempenho
- **Tempo de Resposta**: Respostas e carregamentos em menos de 5 segundos.
- **Utilização de Recursos**: Otimizar o uso de hardware e software nos dispositivos.
- **Capacidade**: Suportar até 5.000 usuários simultâneos.

### 5. Segurança
- **Confidencialidade**: Apenas usuários autorizados acessam dados sensíveis.
- **Integridade**: Proteção contra alterações indevidas de dados.
- **Autenticidade**: Autenticar corretamente os usuários.

### 6. Manutenibilidade
- **Modularidade**: Arquitetura modular para facilitar futuras atualizações.
- **Reusabilidade**: Componentes reutilizáveis para melhorias futuras.
- **Analisabilidade**: Código fácil de entender para rápida depuração.

### 7. Portabilidade
- **Adaptabilidade**: Funciona em diferentes dispositivos (iOS e Android).
- **Instalabilidade**: Fácil de instalar nos dispositivos móveis.
- **Substituibilidade**: Transição fácil do sistema manual para o digital.

### 8. Escalabilidade
- **Crescimento**: Sistema escalável para crescimento de funcionalidades e usuários.
- **Elasticidade**: Adaptar-se a variações de carga sem queda de desempenho.


